# Data Model: Todo Full-Stack Web Application (Phase 2)

**Date**: 2025-02-15
**Feature**: 002-fullstack-web-app
**Purpose**: Define entities, relationships, and database schema for multi-user todo application

## Overview

Phase 2 extends the Phase 1 Task entity with multi-user support. The data model introduces a User entity and modifies the Task entity to include user ownership. All data is persisted in Neon PostgreSQL using SQLModel ORM.

## Entities

### User Entity

Represents a registered user account with authentication credentials.

**Fields:**

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | UUID | PRIMARY KEY, AUTO | Unique user identifier (generated by database) |
| email | VARCHAR(255) | UNIQUE, NOT NULL | User's email address (used for authentication) |
| password_hash | VARCHAR(255) | NOT NULL | Bcrypt-hashed password (never store plain text) |
| created_at | TIMESTAMP | DEFAULT NOW() | Account creation timestamp |

**Validation Rules:**
- Email must be valid format (RFC 5322 compliant)
- Email must be unique across all users
- Password must be minimum 8 characters before hashing
- Password hash uses bcrypt with automatic salt generation

**Business Rules:**
- Users cannot be deleted if they have tasks (CASCADE delete will remove tasks)
- Email is case-insensitive for uniqueness checks
- User ID is immutable once created

**SQLModel Definition:**
```python
from sqlmodel import SQLModel, Field
from uuid import UUID, uuid4
from datetime import datetime

class User(SQLModel, table=True):
    __tablename__ = "users"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    email: str = Field(max_length=255, unique=True, index=True)
    password_hash: str = Field(max_length=255)
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

---

### Task Entity (Extended from Phase 1)

Represents a todo item owned by a specific user. Extends Phase 1 Task with user_id foreign key.

**Fields:**

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | SERIAL | PRIMARY KEY, AUTO | Unique task identifier (auto-increment) |
| user_id | UUID | FOREIGN KEY (users.id), NOT NULL, INDEX | Owner of this task |
| title | VARCHAR(200) | NOT NULL | Task title (1-200 characters) |
| description | TEXT | NULLABLE | Optional task description (0-1000 characters) |
| completed | BOOLEAN | DEFAULT FALSE | Completion status |
| created_at | TIMESTAMP | DEFAULT NOW() | Task creation timestamp |
| updated_at | TIMESTAMP | DEFAULT NOW() | Last modification timestamp |

**Validation Rules (from Phase 1):**
- Title: Required, 1-200 characters, no leading/trailing whitespace
- Description: Optional, 0-1000 characters, empty string allowed
- Completed: Boolean only (true/false)
- User ID: Must reference existing user

**Business Rules:**
- Tasks are private to the user who created them
- Users can only view/modify/delete their own tasks
- Deleting a user cascades to delete all their tasks
- Task ID is immutable once created
- Updated_at automatically updates on any field change

**SQLModel Definition:**
```python
from sqlmodel import SQLModel, Field, Relationship
from uuid import UUID
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    title: str = Field(max_length=200)
    description: str = Field(default="")
    completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationship (optional, for ORM convenience)
    # user: Optional["User"] = Relationship(back_populates="tasks")
```

---

## Relationships

### User → Tasks (One-to-Many)

- **Cardinality**: One User has zero or many Tasks
- **Foreign Key**: Task.user_id → User.id
- **Cascade**: ON DELETE CASCADE (deleting user deletes all their tasks)
- **Indexing**: user_id is indexed for fast filtering

**Query Patterns:**
```sql
-- Get all tasks for a user
SELECT * FROM tasks WHERE user_id = ?;

-- Count tasks per user
SELECT user_id, COUNT(*) FROM tasks GROUP BY user_id;

-- Get incomplete tasks for a user
SELECT * FROM tasks WHERE user_id = ? AND completed = false;
```

---

## Database Schema (PostgreSQL)

### Users Table

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Indexes
CREATE UNIQUE INDEX idx_users_email ON users(LOWER(email));
```

### Tasks Table

```sql
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200) NOT NULL,
    description TEXT DEFAULT '',
    completed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_completed ON tasks(completed);
CREATE INDEX idx_tasks_user_completed ON tasks(user_id, completed);
```

### Triggers (Auto-update updated_at)

```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_tasks_updated_at
    BEFORE UPDATE ON tasks
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

---

## Data Migration Strategy

### From Phase 1 to Phase 2

Phase 1 used in-memory storage with no user concept. Phase 2 requires migration strategy:

**Option 1: Fresh Start (Recommended for Phase 2)**
- No data migration needed
- Users start with empty task lists
- Simpler implementation for hackathon timeline

**Option 2: Import Phase 1 Data (Future Enhancement)**
- Create a default "imported" user account
- Assign all Phase 1 tasks to this user
- Provide import script for users who want to preserve data

**For Phase 2 Hackathon**: Use Option 1 (fresh start)

---

## Alembic Migrations

### Initial Migration (001_initial_schema.py)

```python
"""Initial schema with users and tasks tables

Revision ID: 001
Revises:
Create Date: 2025-02-15
"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID

revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    # Create users table
    op.create_table(
        'users',
        sa.Column('id', UUID(as_uuid=True), primary_key=True, server_default=sa.text('gen_random_uuid()')),
        sa.Column('email', sa.String(255), nullable=False, unique=True),
        sa.Column('password_hash', sa.String(255), nullable=False),
        sa.Column('created_at', sa.TIMESTAMP, server_default=sa.text('NOW()'))
    )
    op.create_index('idx_users_email', 'users', [sa.text('LOWER(email)')], unique=True)

    # Create tasks table
    op.create_table(
        'tasks',
        sa.Column('id', sa.Integer, primary_key=True, autoincrement=True),
        sa.Column('user_id', UUID(as_uuid=True), sa.ForeignKey('users.id', ondelete='CASCADE'), nullable=False),
        sa.Column('title', sa.String(200), nullable=False),
        sa.Column('description', sa.Text, server_default=''),
        sa.Column('completed', sa.Boolean, server_default='false'),
        sa.Column('created_at', sa.TIMESTAMP, server_default=sa.text('NOW()')),
        sa.Column('updated_at', sa.TIMESTAMP, server_default=sa.text('NOW()'))
    )
    op.create_index('idx_tasks_user_id', 'tasks', ['user_id'])
    op.create_index('idx_tasks_completed', 'tasks', ['completed'])
    op.create_index('idx_tasks_user_completed', 'tasks', ['user_id', 'completed'])

    # Create trigger for updated_at
    op.execute("""
        CREATE OR REPLACE FUNCTION update_updated_at_column()
        RETURNS TRIGGER AS $$
        BEGIN
            NEW.updated_at = NOW();
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
    """)
    op.execute("""
        CREATE TRIGGER update_tasks_updated_at
            BEFORE UPDATE ON tasks
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
    """)

def downgrade():
    op.drop_table('tasks')
    op.drop_table('users')
    op.execute('DROP FUNCTION IF EXISTS update_updated_at_column() CASCADE;')
```

---

## Data Access Patterns

### User Repository

```python
class UserRepository:
    """Repository for User entity operations."""

    async def create(self, email: str, password_hash: str) -> User:
        """Create new user account."""
        pass

    async def get_by_id(self, user_id: UUID) -> Optional[User]:
        """Get user by ID."""
        pass

    async def get_by_email(self, email: str) -> Optional[User]:
        """Get user by email (case-insensitive)."""
        pass

    async def exists_by_email(self, email: str) -> bool:
        """Check if email already registered."""
        pass
```

### Task Repository (Extended from Phase 1)

```python
class TaskRepository:
    """Repository for Task entity operations with user filtering."""

    async def create(self, user_id: UUID, title: str, description: str = "") -> Task:
        """Create new task for user."""
        pass

    async def get_by_id(self, task_id: int, user_id: UUID) -> Optional[Task]:
        """Get task by ID (user-filtered)."""
        pass

    async def list_all(self, user_id: UUID) -> List[Task]:
        """List all tasks for user."""
        pass

    async def update(self, task_id: int, user_id: UUID, **updates) -> Task:
        """Update task (user-filtered)."""
        pass

    async def delete(self, task_id: int, user_id: UUID) -> bool:
        """Delete task (user-filtered)."""
        pass

    async def toggle_complete(self, task_id: int, user_id: UUID) -> Task:
        """Toggle task completion status (user-filtered)."""
        pass
```

---

## Performance Considerations

### Indexes

- **users.email**: Unique index with LOWER() for case-insensitive lookups
- **tasks.user_id**: Index for fast user filtering (most common query)
- **tasks.completed**: Index for filtering by status
- **tasks(user_id, completed)**: Composite index for combined filtering

### Query Optimization

- Always filter tasks by user_id first (indexed)
- Use pagination for large task lists (LIMIT/OFFSET)
- Avoid N+1 queries (use joins if loading user with tasks)
- Connection pooling via Neon (automatic)

### Estimated Data Volume

- Users: 100-1000 users (hackathon scale)
- Tasks: 10-1000 tasks per user
- Total tasks: 1,000-100,000 tasks
- Database size: < 100MB (well within Neon free tier)

---

## Security Considerations

### Password Storage

- **NEVER** store plain text passwords
- Use bcrypt with automatic salt (via passlib)
- Minimum 8 characters enforced at API layer
- Password hash stored in password_hash field (255 chars)

### User Isolation

- **ALL** task queries MUST filter by user_id
- API middleware extracts user_id from JWT token
- Database foreign key enforces referential integrity
- No cross-user data access possible

### SQL Injection Prevention

- SQLModel uses parameterized queries (safe by default)
- Never concatenate user input into SQL strings
- Validate all inputs at API layer before database

---

## Testing Strategy

### Unit Tests (Domain Layer)

- Task entity validation (title length, description length)
- User entity validation (email format, password requirements)
- Business rule enforcement (user isolation, cascade deletes)

### Integration Tests (Repository Layer)

- User CRUD operations
- Task CRUD operations with user filtering
- Foreign key constraints
- Cascade delete behavior
- Index performance

### API Tests (Endpoint Layer)

- Authentication flow (signup, signin, signout)
- Task operations with JWT authentication
- User isolation (cannot access other users' tasks)
- Error handling (404, 401, 403, 400)

---

## Conclusion

The Phase 2 data model extends Phase 1 with multi-user support while preserving the core Task entity structure. The User entity enables authentication and task ownership. All validation rules from Phase 1 remain intact, with additional user_id filtering for data isolation.

**Key Changes from Phase 1:**
- Added User entity with authentication fields
- Added user_id foreign key to Task entity
- Added database indexes for performance
- Added cascade delete for user → tasks relationship
- Preserved all Phase 1 validation rules

**Ready for API Contract Generation**: Proceed to contracts/api-endpoints.md
